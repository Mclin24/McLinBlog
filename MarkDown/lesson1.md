## 事件循环

## 渲染主线程

    渲染主线程是浏览器中最繁忙的线程，处理的任务包括但不限于：
    1、解析HTML、CSS
    2、计算样式
    3、布局
    4、处理图层
    5、每秒把页面画60次（60帧）
    6、执行全局JS代码
    7、执行事件处理函数
    8、执行计时器的回调函数
    、、、、

    渲染主线程：

    微队列：

    交互队列：

    延时队列：

## 如何理解 JS 的异步

    JS是一门单线程的语言，它运行在浏览器的渲染线程中，而渲染线程只有一个；
    渲染线程只要是负责HTML，CSS的解析，执行JS，渲染页面，执行计时器回调等工作；
    如果使用同步的方式，就有可能会造成阻塞的问题，从而导致消息队列中的任务无法执行，
    白白消耗渲染主线程的时间，一方面是页面无法及时更新，给用户造成卡死现象。
    所以浏览器采用异步的方式来避免以上问题。
    具体做法是，当某些任务发生时，比如计时器，网络，事件监听，主线程会将任务分配给其他线程处理，
    主线就去执行后续的任务代码。而其他线程处理完任务之后，会将事先传递的回调函数包装成任务，
    推送到消息队列的末尾等待主线线程执行。这样就避免了阻塞问题，保证了单线程的流畅运行

## 交互线程

    例如： h1.textContent = '123123'，delay（3000）
    改变页面元素的内容，会推送绘制任务到消息队列等待执行，以上的例子就会导致页面等待3秒之后才更新
    JS的执行会影响页面的绘制

## 任务有优先级吗

    任务是没有优先级的，在消息队列中先进先出
    但是消息队列是有优先级的：
        1、任务都有类型，同一类型的任务必须在同一个队列中，不同类型任务可以属于不同的队列。
           在一次事件循环中，浏览器可根据实际情况从不同的队列中取出任务执行
        2、浏览器必须准备一个微队列，微队列中的任务优先所有其他任务执行
    在目前的chrome的实现中，至少包含下面的队列
    · 延时队列：用于存放计时器到达后的回调任务，优先级（中）
    · 交互队列：用于存放用户操作后产生的事件任务，优先级（高）
    · 微队列：用户存放需要最快执行的任务，优先级（最高）
    添加任务到微队列的主要方式有：Promise，MutationObserver

## 阐述一下 JS 的事件循环

    事件循环又叫做消息循环，是浏览器渲染主线程的工作方式
    在 Chrome的源码中，它开启一个不会结束的循环，每次循环从消息队列中取出第一个任务执行，
    而其他线程只需要在合适的时候将任务推送到队列末尾即可
    过去把消息队列分为宏队列和微队列，这种说法已经满足不了现在浏览器的复杂情况，取而代之的是一种更加灵活多变的处理方式
    根据W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，
    不同任务有不同的优先级，在一次事件循环中，由浏览器决定取那个队列的任务。但是浏览器必须要有一个微队列。
    微队列的任务一定具有最高优先级，必须优先调度执行

## 总结

    单线程是异步产生的原因，事件循环是异步的实现方式

1、用户交互是由浏览器进程处理的，会把处理的任务交给消息队列，等待渲染主线程去执行
